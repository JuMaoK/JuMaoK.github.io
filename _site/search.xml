<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[Egg Dropping problem]]></title>
      <url>/%E7%AE%97%E6%B3%95/2018/10/13/egg-dropping/</url>
      <content type="text"><![CDATA[  reference  2 Eggs, 100 Floors  2 Eggs, k Floors  N Eggs, k Floors          思路      代码(有bug)      reference  Egg Dropping2 Eggs, 100 Floors二分法在这里不可行。最优是从14层开始丢。            1st egg      if the first egg breaks –&gt; 2nd egg      drops                  14      1-2-3-4-5-6-7-8-9-10-11-12-13      1+13=14              27      15-16-17-18-19-20-21-22-23-24-25-26      2+12=14              …                            95      91-92-93-94      10+4=14              99      100      11+1=12      这种办法，大部分情况都只需最多14次就能找到n。2 Eggs, k Floors  A good way to start this problem is to ask “Are we able to cover all the floors with  x drops?”The crucial point here is understanding that we are not trying to find the minimum number of drops knowing the best strategy; actually, we are trying to find the best strategy supposing that the minimum number of drops is , and we have to determine if covering all the floors using at most  attempts is possible or not.如引述，解决这个问题的思路从最小次数变为覆盖所有楼层（k层）的最小次数。假设从x层开始，覆盖x次，总共可以覆盖：\( x + (x-1)  + (x-2) + (x-3) + … + 2 + 1 (+ 0) = \frac {x(x+1)} {2} \)层楼。为使覆盖楼层大于等于k层，即：\( \frac {x(x+1)} {2} \geq k \)解方程，得：\( x = \frac {-1 + \sqrt{1+8k}} {2} \)注意：x必须为整数如2蛋100层的情况，x = 13.65 = 14N Eggs, k Floors问题要求我们用最少的鸡蛋，覆盖所有k楼层（在最坏的情况下）。要比较有效率地解决这个问题，需要先知道以下的数学例子：组合 (Combinations)\( C\binom{n}{k} = C(n, k) = \binom{n}{k} = \frac{n!}{k!(n-k)!} \)杨辉三角 (Pascal triangle)并且可找到规律：\( C(n, k) = C(n-1, k) + C(n-1, k-1) \)\( C(n, 0) = \frac{n!}{0!(n-0)!} = 1$  and  $C(n, n) = \frac{n!}{n!(n-n)!} = 1 \)思路设方程$f(d, n)$，代表用被覆盖的楼层数。其中，n代表剩余的鸡蛋，d代表在最坏情况下，剩下所需投下的次数。（可以用2蛋100层的例子简化思路来理解）  蛋碎了：剩下$f(d-1, n-1)$层楼需要被覆盖；  蛋不碎：剩下$f(d-1, n)$层楼需要被覆盖所以：\(f(d, n) = 1 + f(d-1, n-1) + f(d-1, n)\)为找到这个方程，我们首先引入一个辅助方程\(g(d, n)\):\(g(d, n) = f(d, n+1) - f(d, n)\)变形可得：\(\begin{align}g(d, n) &amp; = f(d, n+1)-f(d,n)\&amp;= f(d-1,n+1)+f(d-1,n)+1-f(d-1,n)-f(d-1,n-1)-1\&amp;=[f(d-1, n+1)-f(d-1,n)] + [f(d-1,n)-f(d-1,n-1)]\&amp;=g(d-1,n) + g(d-1,n-1)\end{align}\)可发现这个公式与上面combinas的公式一模一样，不妨把它写作\(g(d,n)=\binom{d}{n}\)但还有个问题，就是$f(0,n)$与$g(0,n)$都等于0，所以需要重设公式：\(g(d,n)=\binom{d}{n+1}\)具体验证就不做了。。。回到$f(d,n)$，求和：\(\begin{align}f(d,n)&amp;=[f(d,n)-f(d,n-1)]\&amp;+[f(d,n-1)-f(d,n-2)]\&amp;+\cdots\&amp;+[f(d,1)-f(d,0)]\&amp;+f(d,0)\end{align}\)因为\(f(d,0)=0\)\(f(d,n) =g(d,n-1)+g(d,n-2) + \cdots + g(d,0)\)并且\(g(d,n)=\binom{d}{n+1}\)所以：\(g(d,n-1)+g(d,n-2) + \cdots + g(d,0) = \binom{d}{n}+\binom{d}{n-1}+\cdots+\binom{d}{1}\)最后：\(f(d,n) = \sum_{i=0}^{N}{\binom{d}{i}}\)求解我们现已至$f(d,n)$的公式，接下来要用它找到最小的扔下次数d。因为$f(d,n)$代表在最坏情况下，用n只蛋在不超过d次内可以覆盖的楼层数。对于k层楼而言，只需要：\(f(d,n)\geq k\)，即\(\sum_{i=0}^{N}{\binom{d}{i}} \geq k\)即告完成！代码(有bug)from math import factorialdef comb(n, k):    return factorial(n) / (factorial(k) * factorial(n-k))def cover_floor(drops, n_eggs):    return sum([comb(drops, N) for N in range(n_eggs+1)])def answer(n_eggs, k_floors):    hi = k_floors    lo = 0    while lo &lt;= hi:        mid = (lo + hi) // 2        if cover_floor(mid, n_eggs) &gt; k_floors:            hi = mid - 1        elif cover_floor(mid, n_eggs) &lt; k_floors:            lo = mid + 1    return lo]]></content>
      <categories>
        
          <category> 算法 </category>
        
      </categories>
      <tags>
        
          <tag> 算法 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Longest increasing subsequence]]></title>
      <url>/%E7%AE%97%E6%B3%95/2018/10/13/Longest-increasing-subsequence/</url>
      <content type="text"><![CDATA[  Reference  应用场景  原理  代码Reference  wiki应用场景两个染色体A、B，有n个共有基因。假设A上基因按1、2、3、4…n排序，B上对应的基因有可能是5、2、1、3、4….这个算法可以找出数量最大的，并且在两个染色体上有相同的顺序（不一定比邻）的子序列。例如：序列5 1 4 2 3的最长上升子序列是1 2 3，最长下降子序列是5 4 2原理代码def longest_increasing_subsequence(X):     """Returns the Longest Increasing Subsequence in the Given List/Array"""     N = len(X)     P = [0] * N    M = [0] * (N + 1)     L = 0     for i in range(N):         lo = 1         hi = L         while lo &lt;= hi:             mid = (lo + hi) // 2             if (X[M[mid]] &lt; X[i]):                 o = mid + 1             else:                 hi = mid - 1         newL = lo         P[i] = M[newL - 1]         M[newL] = i        if (newL &gt; L):             L = newL    S = []    k = M[L]    for i in range(L - 1, -1, -1):         S.append(X[k])        k = P[k]    return S[::-1] ]]></content>
      <categories>
        
          <category> 算法 </category>
        
      </categories>
      <tags>
        
          <tag> 算法 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Longest common subsequence problem]]></title>
      <url>/%E7%AE%97%E6%B3%95/2018/10/13/Longest-Common-Subsequence-Problem/</url>
      <content type="text"><![CDATA[  References  Python代码          Recursion      Dynamic Programming        原理：Solution for two sequences          Prefixes                  First property          Second property                    例子        Pseudocode          LCS长度计算      读取一个LCS（只读取了多个可能中的一种）      读取所有LCS      References  wiki  alogorithm不同于 longest common substring promblem，最长共有序列可以在各序列中以不连续的方式出现（not required to be contiguous）。例如，DNA中编码区常常被内含子所隔开，但它通过RNA剪切后，转录所得的mRNA可能在多个物种中是一样的。Python代码Recursiondef lcs(xstr, ystr):    """    &gt;&gt;&gt; lcs('thisisatest', 'testing123testing')    'tsitest'    """    if not xstr or not ystr:        return ""    x, xs, y, ys = xstr[0], xstr[1:], ystr[0], ystr[1:]    if x == y:        return x + lcs(xs, ys)    else:        return max(lcs(xstr, ys), lcs(xs, ystr), key=len)Dynamic Programmingdef lcs(a, b):     lengths = [[0 for j in range(len(b)+1)] for i in range(len(a)+1)]     # row 0 and column 0 are initialized to 0 already     for i, x in enumerate(a):         for j, y in enumerate(b):             if x == y:                 lengths[i+1][j+1] = lengths[i][j] + 1             else:                 lengths[i+1][j+1] = max(lengths[i+1][j], lengths[i][j+1])     # read the substring out from the matrix     result = ""     x, y = len(a), len(b)     while x != 0 and y != 0:         if lengths[x][y] == lengths[x-1][y]:             x -= 1         elif lengths[x][y] == lengths[x][y-1]:             y -= 1         else:             assert a[x-1] == b[y-1]             result = a[x-1] + result             x -= 1             y -= 1     return result 原理：Solution for two sequencesPrefixes前缀，如序列(AGCA)，它的4个可能的prefixs是：S1 = (A)S2 = (AG)S3 = (AGC)S4 = (AGCA)数字代表含有几个字母。两个序列的LCS的计算依赖于以下两个特性。First property情况1:两个序列的终点元素一样。寻找LCS相当于寻找同时减去最后一个元素的两个序列的LCS（再在后面加上这个相同的元素）。例子：(BANANA) and (ATANA)，不断地将最后一位相同的元素去掉，剩下(BAN) and (AT)，它们的LCS是(A)，所以LCS是(AANA)。此特性归纳为：对于比较的序列X和Y，长度分别为n和m：If: Xn=Ymthen: LCS(Xn, Ym) = LCS( Xn-1, Ym-1) ^ Xn^号代表将Xn添加到序列中。Second property情况2:两个序列的终点元素不一样。LCS(Xn, Ym)为LCS(Xn, Ym-1)和LCS(Xn-1, Ym)两者中，较长的那一个。例子X：ABCDEFG (n elements)Y：BCDGK (m elements)LCS(Xn, Ym)要么以G为终点（Y也有G），要么不以G为终点。case1：the LCS ends with a G以G为终点，则不可能以K为终点，所以可以安全地将K去掉（如果K在LCS中，它就会是最后一个）。LCS(Xn, Ym) = LCS(Xn, Ym-1)case 2: the LCS does not end with a G同理，不以G为终点，则可以安全地将G去掉。LCS(Xn, Ym) = LCS(Xn-1, Ym)所以无论是哪个情况，LCS(Xn, Ym)为LCS(Xn, Ym-1)和LCS(Xn-1, Ym)两者中，较长的那一个。**例子：寻找R = (GAC) and C = (AGCAT)的LCS **设空集为所有序列的前缀，即R0 = Ø， C0 = Ø，如下表                   Ø      A      G      C      A                  Ø      Ø      Ø      Ø      Ø      Ø              G      Ø                                          A      Ø                                          C      Ø                                  表格用于储存每一步的计算结果。第二行和第二列都为Ø，是因为当一个空序列与非空序列做比较时，LCS永远为空。过程如下表(箭头表示LCS来自于哪个cell)                   Ø      A      G      C      A      T                  Ø      Ø      Ø      Ø      Ø      Ø      Ø              G      Ø      Ø      (G)      (G)      (G)      (G)              A      Ø      (A)      (A) &amp; (G)      (A) &amp; (G)      (GA)      (GA)              C      Ø      (A)      (A) &amp; (G)      (AC) &amp; (GC)      (AC)&amp;(GC)&amp;(GA)      (AC)&amp;(GC)&amp;(GA)        LCS(R1, C1)，G和A不一样，所以LCS(R1, C1) = LCS(R1, C0) 或LCS(R0, C1) 。这两个可能的结果，如表所示，都为Ø。  LCS(R1, C2)，G和G相同，所以结果为LCS(R0, C1) + G，（ØG），即（G）。  LCS(R1, C3)，G和C不一样，LCS(R0, C3)为Ø，LCS(R1, C2)为（G），选最长那个。      LCS(R1, C4)，LCS(R1, C5)同理，结果为（G）    LCS(R2, C1)，A和A相同，结果为（A）。  LCS(R2, C2)，A和G不一样，结果为（A）或（G）。  其它同理。回溯在序列非常长的时候，这样的方法会消耗大量的储存空间。为避免此问题，不应储存具体的序列，而只需箭头的指向和LCS的长度，如下表。                   Ø      A      G      C      A      T                  Ø      0      0      0      0      0      0              G      0      0      1      1      1      1              A      0      1      1      1      2      2              C      0      1      1      2      2      2      从右下角开始，随箭头方向移动。当长度减少时，表示两序列有一个共有元素（表中红色数字所在cell）。如果同一个cell里含两个箭头，表示有两种可能。PseudocodeLCS长度计算function LCSLength(X[1..m], Y[1..n])    C = array(0..m, 0..n)    for i := 0..m       C[i,0] = 0    for j := 0..n       C[0,j] = 0    for i := 1..m        for j := 1..n            if X[i] = Y[j]                C[i,j] := C[i-1,j-1] + 1            else                C[i,j] := max(C[i,j-1], C[i-1,j])    return C[m,n]读取一个LCS（只读取了多个可能中的一种）function backtrack(C[0..m,0..n], X[1..m], Y[1..n], i, j)    if i = 0 or j = 0        return ""    if  X[i] = Y[j]        return backtrack(C, X, Y, i-1, j-1) + X[i]    if C[i,j-1] &gt; C[i-1,j]        return backtrack(C, X, Y, i, j-1)    return backtrack(C, X, Y, i-1, j)读取所有LCSfunction backtrackAll(C[0..m,0..n], X[1..m], Y[1..n], i, j)    if i = 0 or j = 0        return {""}    if X[i] = Y[j]        return {Z + X[i] for all Z in backtrackAll(C, X, Y, i-1, j-1)}    R := {}    if C[i,j-1] ≥ C[i-1,j]        R := R ∪ backtrackAll(C, X, Y, i, j-1)    if C[i-1,j] ≥ C[i,j-1]        R := R ∪ backtrackAll(C, X, Y, i-1, j)    return R]]></content>
      <categories>
        
          <category> 算法 </category>
        
      </categories>
      <tags>
        
          <tag> 算法 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Binary Search]]></title>
      <url>/%E7%AE%97%E6%B3%95/2018/10/13/Binary-Search/</url>
      <content type="text"><![CDATA[  A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a “divide and conquer” algorithm.  As an analogy, consider the children’s game “guess a number.” The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.  As the player, an optimal strategy for the general case is to start by choosing the range’s midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.from bisect import bisect_left def binary_search(lst, x): ​    i = bisect_left(lst, x) ​    if i != len(lst) and lst[i] == x:   # ？ ​        return i ​    raise ValueError ]]></content>
      <categories>
        
          <category> 算法 </category>
        
      </categories>
      <tags>
        
          <tag> 算法 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[0/1 Knapsack problem]]></title>
      <url>/%E7%AE%97%E6%B3%95/2018/10/13/0-1-Knapsack-problem/</url>
      <content type="text"><![CDATA[  References  原理          Dynamic programming                  pseudo code                      Python代码          Dynamic programming solution      Recursive dynamic programming algorithm      References  wiki  algorithm遇到这个算法源于PS4游戏搞活动550-100，我需要凑够550元多一点的游戏。只有两三个游戏是我特别想买的，另外好几个是都可以接受的选择，我需要从中挑选出几个。类似问题也在双十一等购物节时碰到。原理0/1 Knapsack problem的经典例子是旅行出外时，用空间有限的行李箱携带效用最高的物品组合。设每个item的取舍xi只有0或1，总共n个items，每个含有权重wi，价值vi，最大重量W。目标：  使总价值v最大化maximize \(\sum_{i=1}^{n}vixi \)  总重量小于Wsubject to \(\sum_{i=1}^{n}wixi \leq W\) and  \(xi \in {0,1}\)更为复杂的有bounded knapsack problem (BKP)和unbounded knapsack problem (UKP) ，详见wiki。Dynamic programming假设所有items的重量均&gt;0，我们想最大化重量少于等于W时所得的价值。设m[i, w]为前 i 个item中，重量小于等于w时的最大价值，可知：  \(m[0,w]=0\)  \(m[i,w]=m[i-1,w-wi] if wi &gt; w\)  \(m[i,w]=max(m[i-1,w], [i-1,w-wi]+vi if wi \leq w) \)那么，解决的办法就是计算m[n, W]。pseudo code 1 // Input: 2 // Values (stored in array v) 3 // Weights (stored in array w) 4 // Number of distinct items (n) 5 // Knapsack capacity (W) 6 // NOTE: The array "v" and array "w" are assumed to store all relevant values starting at index 1. 7  8 for j from 0 to W do: 9     m[0, j] := 010 11 for i from 1 to n do:12     for j from 0 to W do:13         if w[i] &gt; j then:14             m[i, j] := m[i-1, j]15         else:16             m[i, j] := max(m[i-1, j], m[i-1, j-w[i]] + v[i])Python代码背景：某人准备出游，背包空间有限，需要从列表中选出最合适的物品。列表如下。Dynamic programming solutiondef totalvalue(comb):    ' Totalise a particular combination of items'    totwt = totval = 0    for item, wt, val in comb:        totwt  += wt        totval += val    return (totval, -totwt) if totwt &lt;= 400 else (0, 0) items = (    ("map", 9, 150), ("compass", 13, 35), ("water", 153, 200), ("sandwich", 50, 160),    ("glucose", 15, 60), ("tin", 68, 45), ("banana", 27, 60), ("apple", 39, 40),    ("cheese", 23, 30), ("beer", 52, 10), ("suntan cream", 11, 70), ("camera", 32, 30),    ("t-shirt", 24, 15), ("trousers", 48, 10), ("umbrella", 73, 40),    ("waterproof trousers", 42, 70), ("waterproof overclothes", 43, 75),    ("note-case", 22, 80), ("sunglasses", 7, 20), ("towel", 18, 12),    ("socks", 4, 50), ("book", 30, 10),    ) def knapsack01_dp(items, limit):    table = [[0 for w in range(limit + 1)] for j in xrange(len(items) + 1)]     for j in xrange(1, len(items) + 1):        item, wt, val = items[j-1]        for w in xrange(1, limit + 1):            if wt &gt; w:                table[j][w] = table[j-1][w]            else:                table[j][w] = max(table[j-1][w],                                  table[j-1][w-wt] + val)     result = []    w = limit    for j in range(len(items), 0, -1):        was_added = table[j][w] != table[j-1][w]         if was_added:            item, wt, val = items[j-1]            result.append(items[j-1])            w -= wt     return result  bagged = knapsack01_dp(items, 400)print("Bagged the following items\n  " +      '\n  '.join(sorted(item for item,_,_ in bagged)))val, wt = totalvalue(bagged)print("for a total value of %i and a total weight of %i" % (val, -wt))Recursive dynamic programming algorithmdef total_value(items, max_weight):    return  sum([x[2] for x in items]) if sum([x[1] for x in items]) &lt; max_weight else 0 cache = {}def solve(items, max_weight):    if not items:        return ()    if (items,max_weight) not in cache:        head = items[0]        tail = items[1:]        include = (head,) + solve(tail, max_weight - head[1])        dont_include = solve(tail, max_weight)        if total_value(include, max_weight) &gt; total_value(dont_include, max_weight):            answer = include        else:            answer = dont_include        cache[(items,max_weight)] = answer    return cache[(items,max_weight)] items = (    ("map", 9, 150), ("compass", 13, 35), ("water", 153, 200), ("sandwich", 50, 160),    ("glucose", 15, 60), ("tin", 68, 45), ("banana", 27, 60), ("apple", 39, 40),    ("cheese", 23, 30), ("beer", 52, 10), ("suntan cream", 11, 70), ("camera", 32, 30),    ("t-shirt", 24, 15), ("trousers", 48, 10), ("umbrella", 73, 40),    ("waterproof trousers", 42, 70), ("waterproof overclothes", 43, 75),    ("note-case", 22, 80), ("sunglasses", 7, 20), ("towel", 18, 12),    ("socks", 4, 50), ("book", 30, 10),    )max_weight = 400 solution = solve(items, max_weight)print "items:"for x in solution:    print x[0]print "value:", total_value(solution, max_weight)print "weight:", sum([x[1] for x in solution])]]></content>
      <categories>
        
          <category> 算法 </category>
        
      </categories>
      <tags>
        
          <tag> 算法 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
