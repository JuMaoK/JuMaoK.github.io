---
layout: post
title: "B-Tree"
tags: [Algorithms, Data structure, Database]
---

B-树及其相关算法

* 目录
{:toc .toc}
---

#### reference

>  [wiki](https://en.wikipedia.org/wiki/B-tree)
>
> [学堂在线](http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184_2X+sp/about)



## Background

由内存与外存（磁盘）组成的二级存储系统中，数据全集往往存放于外存中。两个相邻存储级别之间的数据传输，统称 I/O 操作。内存和磁盘单词访问延迟大致在纳秒（ns）和毫秒（ms）级别，相差5-6个数量级。因此，衡量相关算法的性能时，会更多地关注对外存的访问次数。

当数据规模大到内存不足以容纳时，由于查找过程对外存的访问次数过多，常规平衡二叉搜索树的效率将大打折扣。为解决此问题，可利用外存的另一特性：就时间成本而言，读取物理地址连续的一千个字节，与读取单个字节几乎没有区别。既然外存更适宜于批量式访问，不妨通过时间成本相对极低的多次内存操作，来替代时间成本相对极高的单次外存操作。

## B-Tree overview

B-树具有与BST同样的查找等操作，但对外存的访问方式已发生本质改变。搜索每下降一层，都以“大节点”为单位从外存读取一组关键码。更重要的是，这组关键码在逻辑上和物理上都彼此相邻，故可以批量方式从外存一次性读出。关键码的最佳数目，取决于不同外存的批量访问特性，比如旋转式磁盘多以扇区为单位，故可根据扇区的容量和关键码的大小，换算得出每组关键码的最佳规模。

一颗m阶B-树中，除根节点外，假设每个节点含n个关键码，$$n+1$$个孩子，则n应满足$$m\ge n+1\ge\lceil{m/2}\rceil$$ 。根节点应满足$$m \ge n+1\ge2$$。由于节点的分支数介于$$\lceil{m/2}\rceil$$至$$m$$之间，因此m阶B数也称作$$(\lceil{m/2}\rceil, m)$$-树，如(2, 3)-树，(7, 13)-树等。

B-树的所有外部节点（external node）深度相等。它们实际上未必意味着查找失败，而可能表示目标关键码存在于更低层次的某一外部存储系统中。

## Algorithms

### Search

B-树查找过程与二叉搜索树基本类似。

首先以根节点作为起点，逐层深入。若在当前节点关键码中找到目标关键码，则返回。若不存在，则在查找“失败”的位置确定节点的某一引用（孩子），并通过它转至逻辑上处于下一层的另一个节点，重复上述过程。

可见，只有在切换和更新当前节点时才会发生I/O操作，节点内部的查找完全在内存中进行。考虑到关键码数量通常在128～1024之间，故可以直接使用顺序查找策略，而不必采用二分查找之类的复杂策略。


### Insertion

在B-树中插入一个新的关键码e。首先在树中查找e，若存在，则根据规定更新值或返回错误。

若e不存在，则查找必然终止于某一外部节点v的秩r，此位置即e的正确插入位置。

将e插入r后，若该节点v关键码总数依然合法（$$m-1\ge n$$），则插入完成，否则，称v发生了一次上溢（overflow），需进行分裂处理。

#### overflow & split

一般地，刚发生上溢的节点，应恰好含有m个关键码。取$$s = \lfloor{m/2}\rfloor$$，以s为界，关键码可分为K0...Ks-1和Ks+1...Km-1两组。于是，另Ks上升一层，归入父节点中的适当位置，并以两组关键码作为它的左、右孩子。不难验证，分裂所得的两个孩子节点，均符合m阶B-树关于节点分枝数的条件。

至于被提升的关键码Ks，有三种可能情况：

1. 父节点存在，且足以接纳一个新的关键码。此时只需将Ks插入到适当位置，修复即告完成。
2. 父节点存在，但业已处于饱和状态。此时插入Ks后将造成父节点上溢，这种现象被称作上溢的向上传递。好在，上溢的传递最远不会超过树根，所以此时只需继续对父节点进行分裂修复即可。
3. 父节点不存在（即上溢发生在树根）。此时让Ks作为新的树根，全树高度上升一层。

*实际上，因插入操作而导致$$\Omega(log_mN)$$次分裂的情况极为罕见，单次插入操作水平引发的分裂次数，远远低于这一估计，故时间通常主要消耗于对目标关键码的查找。（TODO：why？）*


### Delete

从B-树中删除关键码e。首先也是在树中查找e。若查找失败，则说明关键码不存在，删除操作结束。查找成功，即可确定关键码所在节点v和秩r。

与BST类似，不妨假定v是叶节点，否则e的直接后继（或前驱）必然存在，直接后继所属节点u必为叶节点，关键码必为u[0]。只要令e与u[0]互换位置，即可确保待删除的关键码e所属节点v是叶节点。

于是，可以直接将e及其左侧的外部空节点从v中删去。此时，若v所含关键码总数依然合法（$$n\ge\lceil{m/2}\rceil-1$$），则删除操作随即完成。否则，称该节点发生了下溢（underflow），需进行修复让节点重新满足条件。

#### underflow & rotation

刚发生下溢的节点v必恰好包含$$\lceil{m/2}\rceil-2$$ 个关键码和$$\lceil{m/2}\rceil-1$$ 个分支。根据左、右兄弟所含关键码数目，可分三种情况进行处理。

1. 左兄弟l存在，并且至少包含$$\lceil{m/2}\rceil$$个关键码

此时，左兄弟即使“借出”一个关键码，仍然会复合条件。为确保B-树的顺序性，应将左兄弟最后一个关键码插入到父节点处，再把父节点相应的关键码插入到v[0]。至此下溢修复完毕。

2. 右兄弟r存在，并且至少包含$$\lceil{m/2}\rceil$$个关键码

与上述操作类似。

#### underflow & merge

3. 左、右兄弟l和r或者不存在，或者包含的关键码不足

实际上，l和r不可能同时不存在，可以不失一般性地设左兄弟l存在，此时l应恰好包含$$\lceil{m/2}\rceil-1$$个关键码。

此时，可从父节点p中抽出介于l和v之间的关键码y，并通过y将l和v“粘接”成一个节点。经合并后，关键码总数应为：

$$(\lceil{m/2}\rceil-1)+1+(\lceil{m/2}\rceil-2) = 2 * \lceil{m/2}\rceil-2 \le m-1$$

节点v的下溢得以修复，同时也不至于引发上溢。

接下来还必须检查父节点p，关键码y的删除可能导致p出现下溢。若发生下溢，仍可以用以上办法解决。即使发生下溢的传递，当下溢传递到根节点且其中不再含有任何关键码时，即可将其删除并代之以其唯一孩子，全树高度下降一层。

