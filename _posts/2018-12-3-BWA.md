---
layout: post
title: "Read alignment with Burrows–Wheeler transform"
tags: [Read alignment, Algorthms]
---

基于Burrows-Wheeler Transform(BWT)算法实现短序列比对。

* 目录
{:toc .toc}
---


# Precalculation

设序列X = ATGCCTTGA，并在X最后一位添加字符'$'或任何在字母表中比X所有字符小的符号。X[i]表示X的第i个字符，将X[i, n-1]表示为X的第i个后缀。

## BW matrix

不断将X的首字符移动到最后一位生成新的序列，将这些序列按字母表排序后，所组成的矩阵即BW matrix（BWM）。矩阵中每一行只需关注首尾两个字符，分别记为F和L。

这只是一个概率，实际应用重没必要真的创建一个BWM（人基因组约3 billion 碱基对，对应的BWM需要$10^{18}$碱基对）。



## Suffix array

后缀数组。BWM中每一条序列从头到$之间都是X的后缀，这些后缀的rank组成suffix array（sa）。以下是它的一种朴素实现：

```python
def create_sa(X):
    suffixes = [(X[i:], i) for i in range(len(X))]
    suffixes.sort()
    return [i for _, i in suffixes]
```



## Burrows-Wheeler Transform

在BWM中，取每一行的最后一个字符，重新组成的新的字符串，即Burrows-Wheeler Transform（BWT）。设B[i]为BWT的第i个字符，它拥有特性：`B[i] = $ if S(i) = 0 else B[i] = X[S(i)−1]`。因此，B[i]是X[S(i)]的前一位字符。以下是它的一种朴素实现：

```python
def create_bwt(X, sa):
    return ''.join(X[si - 1] for si in sa)
```



## Suffix array interval

假设序列W是X的子序列，由于BWM是按字母表排序的，那么所有在X中搜索到的W都会紧挨着地出现在suffix array中。设:

![sa interval](https://wx3.sinaimg.cn/mw690/006SeTXOgy1fxnjq9vxgvj308301j0sv.jpg)

如果W是空序列，则两者分别为1和n-1，n为X的长度。

两者组成的区间即sa区间。



## Auxiliary data structures

设`C(a)`，表示字母顺序小于字符a的字符在X中出现的次数。

设`O(a, i)`，表示在B[0, i]中字符a出现的次数。

以下是它们的朴素实现：

```python
def create_c_occ(seq, bwt, symbol='$'):
    c = {}
    count = Counter(seq)
    total = 0
    for i in sorted(count):
        c[i] = total
        total += count[i]

    del count[symbol]
    occ = {l: [0] for l in count}
    occ[bwt[0]] = [1]
    for char in bwt[1:]:
        for l in count:
            occ[l].append(occ[l][-1] + (l == char))
    return c, occ
```

这两个函数生成的数据结构，配合BWM按字母表排序的特性，可以实现搜索区间的定位：



# Exact matching

子序列W的前一字符为a的sa区间，符合以下规律：

$$R\_(aW) = C(a) + O(a, R\_(W) - 1) + 1$$

$$R^{-}(aW) = C(a) + O(a, R^{-}(W)) $$

简单来说，由于BWM是按字母表排序的，所以某字符a出现的区间肯定在字母表顺序刚好小于a的字符的后面，即$$[C(a), n-1]$$；

*在进一步缩小范围之前，需要了解一个规律：BWM中，某一字符a，它在F列与L列中的排序是一致的，这是因为1）F列中a相等，不影响排序，影响排序的是它们后面的字符串；2）L列中a的顺序是由前面的序列决定的。3）假设X中a有m个，那么F列中m个影响排序的片段与影响L列排序的片段是一模一样的，只是相当于将F中的a移动到最后一位而已。因此，它们的排序是肯定相同的。*

第二步，排除处于搜索区间（W所处区间）之外的a，$$[O(a, R\_(W)-1) + 1, O(a, R^{-}(W)]$$

以下是它的素朴实现（python中需稍作修改）：

```python
def find_interval(lo, up, char, c, occ):
    lo = c[char] + occ[char][lo - 1] if lo >= 1 else c[char]
    up = c[char] + occ[char][up] - 1
    return lo, up

def pre_cal(seq, symbol='$'):
    seq += symbol
    sa = create_sa(seq)
    bwt = create_bwt(seq, sa)
    c, occ = create_c_occ(seq, bwt)

    return sa, c, occ

def backward_search(query, reference, pre_cals=None, interval=None):
    assert len(query) > 0
    pre_cals = pre_cal(reference) if pre_cals is None else pre_cals
    sa, c, occ = pre_cals
    lo, up = (0, len(reference)) if interval is None else interval

    query = [i for i in query]
    target = query.pop()
    lo, up = find_interval(lo, up, target, c, occ)
    while query:
        target = query.pop()
        lo, up = find_interval(lo, up, target, c, occ)
        if lo > up:
            return []

    return sorted(sa[lo: up+1])
```

以X = ATGCCTTGA$搜索TGA举例：

```python
sa:  [9, 8, 0, 3, 4, 7, 2, 6, 1, 5]
bwt:  AG$GCTTTAC
C:  {'$': 0, 'A': 1, 'C': 3, 'G': 5, 'T': 7}
O:  {'A': [1, 1, 1, 1, 1, 1, 1, 1, 2, 2], 
       'T': [0, 0, 0, 0, 0, 1, 2, 3, 3, 3], 
       'G': [0, 1, 1, 2, 2, 2, 2, 2, 2, 2], 
       'C': [0, 0, 0, 0, 1, 1, 1, 1, 1, 2]}
```

首先搜索的是最右边的A，此时搜索区间为整个序列，即[0, n]。调用`find_interval`，确定BWM中F列为A的行的区间为：C['A'] to C['A'] + O\['A'][n - 1] - 1 = [1, 2]。

然后搜索G，此时搜索区间为[1, 2]。同理，搜索结果为[5, 5]。

最后搜索T，此时搜索区间为[5]。同理，所搜结果为[7, 7]。

搜索结束，确认TGA为X子序列，在X所处位置为sa[7] = 6。



# Inexact matching

在允许z次错配的情况下，一个比较直接的办法是设置一个变量z，每次遇到错配，z-1，当z小于0时比对结束。但可以想象，这种办法的效率并不高。在极端的情形下，前z次的比对都不会缩小比对的范围。

为了更有效地缩小比对范围，设数组D为query序列W在reference序列X上差别的lower bound (LB)。

D的一个朴素实现如下：

```python
def calD(W, X):
    _, c, occ2 = pre_cal(X[::-1])
    z, lo, up = 0, 0, len(X)
    D = []
    for i in range(len(W)):
        lo, up = find_interval(lo, up, W[i], c, occ2)
        if lo > up:
            lo, up = up - 1, len(X)
            z += 1
        D.append(z)
    return D
```

可见，`calD`类似于在X的**反向**（非互补）序列中搜索W的**反向**序列的sa区间。但与exact matching不同的是，一旦被搜索失败，z+1，并将搜索区间重置，然后继续搜索下一个字符。

一个更容易理解但低效的版本：

```python
def calD(W, X):
	z, j = 0, 0
    D = []
    for i in range(1, len(W) + 1):
        if W[j, i] not in X:
            z += 1
            j = i + 1
		D.append(z)
	return D
```

不断测试W的前缀是否为X的子序列，一旦遇到错配则从下一个字符继续。

所以，数组D的意义在于，指出当搜索完W[i+1:]后，剩下的序列还将发生多少次错配。如果允许错配的次数小于D[i]，则没必要进行下去。

D[i]的数值意味着，当W[i:]比对完成，W[i]在X上做对比的时候，允许错配的次数z必须不小于D[i]，否则比对结束。

获得D后，即可对序列进行非严格比对，下面是一种朴素实现：

```python
def InexSearch(query, reference, z):
    D = calD(query, reference)
    sa, c, occ = pre_cal(reference)

    def InexRecur(query, i, z, lo, up):
        nonlocal c, occ, D

        if z < D[i]:
            return []
        if i < 0:
            return [[lo, up]]

        I = []
        # insertions
        I.extend(InexRecur(query, i - 1, z - 1, lo, up))
        for b in 'ACGT':
            new_lo, new_up = find_interval(lo, up, b, c, occ)
            if new_lo <= new_up:
                # deletions
                I.extend(InexRecur(query, i, z - 1, new_lo, new_up))
                if b == query[i]:
                    I.extend(InexRecur(query, i - 1, z, new_lo, new_up))
                else:
                    I.extend(InexRecur(query, i - 1, z - 1, new_lo, new_up))
        return I

    i, len_ref = len(query) - 1, len(reference)
    I = InexRecur(query, i, z, 0, len_ref)
    pos = [sa[lo: up+1] for lo, up in I]
    result = {j for i in pos for j in i}
    return result
```



上述实现有不少可以优化的地方，比如某些情况可以预先把reference的c、occ准备好，有的时候则适合把query的index准备好。另一个问题是，完整读取occ和sa需要消耗大量的内存，但可以用FM index解决。

另外，实际应用中，往往需要对颠换、转换、插入、缺失几种mismatches给予不同的权重，这时候用heap-like的数据结构代替递归更加合适。







